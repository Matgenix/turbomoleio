<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>turbomoleio.output.parser &mdash; turbomoleio 1.1.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> turbomoleio
          </a>
              <div class="version">
                1.1.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../datagroups.html">The data group files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../coord.html">The coord file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../definerunner.html">Running define</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output_parsing.html">Outputs parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../appendix.html">Appendix</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/introduction.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/parsing_logs.html">Output logs parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/definerunner.html">Define runner</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/versioning.html">Versioning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/versioning.html#backward-compatibility">Backward-compatibility</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bugs.html">Reporting bugs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">turbomoleio</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>turbomoleio.output.parser</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for turbomoleio.output.parser</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># The turbomoleio package, a python interface to Turbomole</span>
<span class="c1"># for preparing inputs, parsing outputs and other related tools.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2018-2021 BASF SE, Matgenix SRL.</span>
<span class="c1">#</span>
<span class="c1"># This file is part of turbomoleio.</span>
<span class="c1">#</span>
<span class="c1"># Turbomoleio is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># Turbomoleio is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with turbomoleio (see ~turbomoleio/COPYING). If not,</span>
<span class="c1"># see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module with the main parsing utilities for the stdout of Turbomole executables.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">monty.functools</span> <span class="kn">import</span> <span class="n">lazy_property</span>


<span class="c1"># common pattern for regex</span>
<span class="n">date_format</span> <span class="o">=</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S.</span><span class="si">%f</span><span class="s2">&quot;</span>
<span class="n">float_number_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[+-]?[0-9]*[.]?[0-9]+&quot;</span>
<span class="n">float_number_d_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[+-]?[0-9]*[.]?[0-9]+D[+-]\d</span><span class="si">{2}</span><span class="s2">&quot;</span>
<span class="n">float_number_e_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[+-]?[0-9]*[.]?[0-9]+E[+-]\d</span><span class="si">{2}</span><span class="s2">&quot;</span>
<span class="n">float_number_all_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[+-]?[0-9]*[.]?[0-9]+(?:[ED][+-]\d</span><span class="si">{2}</span><span class="s2">)?&quot;</span>
<span class="n">irrep_re_group</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\w&#39;</span><span class="se">\&quot;</span><span class="s2">&quot;</span>


<span class="c1"># pre compiled regex</span>
<span class="n">asterisks_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\*+&quot;</span><span class="p">)</span>


<span class="c1"># strings present in the output for all the types of standard xc functionals.</span>
<span class="c1"># NB This should be updated if other standard xc functionals are added to TM.</span>
<span class="n">functional_strings</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;s-vwn&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Slater.+?Dirac.+?exchange.+?with.+?VWN.+?corr\..+?functional&quot;</span><span class="p">,</span>
    <span class="s2">&quot;s-vwn_Gaussian&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Slater.+?Dirac.+?exchange.+?with.+?VWN.+?corr\.functional.+?\(fit.+?III.+?as.+?in.+?Gaussian\)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pwlda&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Slater.+?Dirac.+?exchange.+?with.+?PW.+?LDA.+?corr\..+?functional&quot;</span><span class="p">,</span>
    <span class="s2">&quot;b-lyp&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;B\-LYP.+?functional.+?exchange\:.+?LDA.+?\+.+?Becke.+?\(B88\).+?correlation\:.+?Lee\-Yang\-Parr.+?\(LYP\)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;b-vwn&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;B\-VWN.+?functional.+?exchange\:.+?LDA.+?\+.+?Becke.+?\(B88\).+?correlation\:.+?LDA.+?\(VWN\)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;b-p&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;B\-P86.+?functional.+?exchange\:.+?LDA.+?\+.+?Becke.+?\(B88\).+?correlation\:.+?LDA.+?\(VWN\).+?\+.+?Perdew.+?\(P86\)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pbe&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;PBE.+?functional.+?exchange\:.+?LDA.+?\+.+?PBE.+?correlation\:.+?LDA.+?\(PW\).+?\+.+?PBE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tpss&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;TPSS.+?meta\-GGA.+?functional.+?exchange\:.+?LDA.+?\+.+?TPSS.+?correlation\:.+?LDA.+?\(PW\).+?\+.+?TPSS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;bh-lyp&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Becke\-Half\-and\-Half\-LYP.+?hybrid.+?functional\:.+?BH\-LYP.+?exchange\:.+?1\/2.+?\(LDA.+?\+.+?Becke.+?\(B88\)\).+?\+.+?1\/2.+?HF.+?correlation\:.+?Lee\-Yang\-Parr.+?\(LYP\)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;b3-lyp&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Becke\-3\-Parameter.+?hybrid.+?functional\:.+?B3\-LYP.+?exchange\:.+?0\.8\*LDA.+?\+.+?0\.72\*B88.+?\+.+?0\.2\*HF.+?correlation\:.+?0\.19\*LDA\(VWN\).+?\+.+?0\.81\*LYP&quot;</span><span class="p">,</span>
    <span class="s2">&quot;b3-lyp_Gaussian&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Becke\-3\-Parameter.+?hybrid.+?functional\:.+?B3\-LYP.+?exchange\:.+?0\.8\*LDA.+?\+.+?0\.72\*B88.+?\+.+?0\.2\*HF.+?correlation\:.+?0\.19\*LDA\(VWNIII\).+?\+.+?0\.81\*LYP.+?\(VWNIII.+?fit.+?as.+?in.+?Gaussian\)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pbe0&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;PBE0.+?hybrid.+?functional.+?exchange\:.+?3\/4.+?\(LDA\+PBE\).+?\+.+?1\/4.+?HF.+?correlation\:.+?LDA.+?\(PW\).+?\+.+?PBE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tpssh&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;TPSS.+?global.+?hybrid.+?functional.+?exchange\:.+?9\/10.+?\(LDA\+TPSS\).+?\+.+?1\/10.+?HF.+?correlation\:.+?LDA.+?\(PW\).+?\+.+?TPSS&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pw6b95&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;PW6B95.+?global.+?meta.+?hybrid.+?functional.+?code.+?by.+?Stefan.+?Grimme\,.+?University.+?of.+?Muenster.+?Zhao.+?and.+?Truhlar\,.+?J.+?Phys.+?Chem.+?A\,.+?109\,.+?25\,.+?2005\,.+?5656\.&quot;</span><span class="p">,</span>
    <span class="s2">&quot;m06&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;M06.+?meta\-GGA.+?functional.+?Truhlar.+?functional.+?with.+?27\%.+?HF.+?exchange.+?USING.+?XCfun.+?library\,.+?see.+?documentation.+?XCFun.+?library.+?is.+?being.+?used\,.+?version\:.+?1\.99000000000000.+?XCFun.+?DFT.+?library.+?Copyright.+?2009\-2011.+?Ulf.+?Ekstrom.+?and.+?contributors\..+?See.+?http\:\/\/admol\.org\/xcfun.+?for.+?more.+?information\..+?This.+?is.+?free.+?software\;.+?see.+?the.+?source.+?code.+?for.+?copying.+?conditions\..+?There.+?is.+?ABSOLUTELY.+?NO.+?WARRANTY\;.+?not.+?even.+?for.+?MERCHANTABILITY.+?or.+?FITNESS.+?FOR.+?A.+?PARTICULAR.+?PURPOSE\..+?For.+?details.+?see.+?the.+?documentation\..+?Scientific.+?users.+?of.+?this.+?library.+?should.+?cite.+?U\..+?Ekstrom\,.+?L\..+?Visscher\,.+?R\..+?Bast\,.+?A\..+?J\..+?Thorvaldsen.+?and.+?K\..+?Ruud\;.+?J\.Chem\.Theor\.Comp\..+?2010\,.+?DOI\:.+?10\.1021\/ct100117s.+?XCFun.+?uses.+?functional\:.+?m06&quot;</span><span class="p">,</span>
    <span class="s2">&quot;m06-l&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;M06\-L.+?meta\-GGA.+?functional.+?Truhlar.+?functional.+?without.+?HF.+?exchange.+?USING.+?XCfun.+?library\,.+?see.+?documentation.+?XCFun.+?library.+?is.+?being.+?used\,.+?version\:.+?1\.99000000000000.+?XCFun.+?DFT.+?library.+?Copyright.+?2009\-2011.+?Ulf.+?Ekstrom.+?and.+?contributors\..+?See.+?http\:\/\/admol\.org\/xcfun.+?for.+?more.+?information\..+?This.+?is.+?free.+?software\;.+?see.+?the.+?source.+?code.+?for.+?copying.+?conditions\..+?There.+?is.+?ABSOLUTELY.+?NO.+?WARRANTY\;.+?not.+?even.+?for.+?MERCHANTABILITY.+?or.+?FITNESS.+?FOR.+?A.+?PARTICULAR.+?PURPOSE\..+?For.+?details.+?see.+?the.+?documentation\..+?Scientific.+?users.+?of.+?this.+?library.+?should.+?cite.+?U\..+?Ekstrom\,.+?L\..+?Visscher\,.+?R\..+?Bast\,.+?A\..+?J\..+?Thorvaldsen.+?and.+?K\..+?Ruud\;.+?J\.Chem\.Theor\.Comp\..+?2010\,.+?DOI\:.+?10\.1021\/ct100117s.+?XCFun.+?uses.+?functional\:.+?m06l&quot;</span><span class="p">,</span>
    <span class="s2">&quot;m06-2x&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;M06\-2X.+?meta\-GGA.+?functional.+?Truhlar.+?functional.+?with.+?54\%.+?HF.+?exchange.+?USING.+?XCfun.+?library\,.+?see.+?documentation.+?XCFun.+?library.+?is.+?being.+?used\,.+?version\:.+?1\.99000000000000.+?XCFun.+?DFT.+?library.+?Copyright.+?2009\-2011.+?Ulf.+?Ekstrom.+?and.+?contributors\..+?See.+?http\:\/\/admol\.org\/xcfun.+?for.+?more.+?information\..+?This.+?is.+?free.+?software\;.+?see.+?the.+?source.+?code.+?for.+?copying.+?conditions\..+?There.+?is.+?ABSOLUTELY.+?NO.+?WARRANTY\;.+?not.+?even.+?for.+?MERCHANTABILITY.+?or.+?FITNESS.+?FOR.+?A.+?PARTICULAR.+?PURPOSE\..+?For.+?details.+?see.+?the.+?documentation\..+?Scientific.+?users.+?of.+?this.+?library.+?should.+?cite.+?U\..+?Ekstrom\,.+?L\..+?Visscher\,.+?R\..+?Bast\,.+?A\..+?J\..+?Thorvaldsen.+?and.+?K\..+?Ruud\;.+?J\.Chem\.Theor\.Comp\..+?2010\,.+?DOI\:.+?10\.1021\/ct100117s.+?XCFun.+?uses.+?functional\:.+?m062x&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lhf&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Localized.+?Hartree\-Fock.+?Methods\:.+?F\..+?Della.+?Sala.+?and.+?A\..+?Goerling\,.+?J\..+?Chem\..+?Phys\..+?115\,.+?5718.+?\(2001\).+?F\..+?Della.+?Sala.+?and.+?A\..+?Goerling\,.+?J\..+?Chem\..+?Phys\..+?116\,.+?5374.+?\(2002\)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;oep&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Exact\-Exchange.+?Optimized.+?Effective.+?Potential.+?Method\:.+?Hesselmann\,.+?A\.\,.+?Goetz\,.+?A\.\,.+?Della.+?Sala\,.+?F\.\,.+?Goerling\,.+?A\.\,.+?J\..+?Chem\..+?Phys\.\,.+?127.+?\(2007\)\,.+?054102&quot;</span><span class="p">,</span>
    <span class="s2">&quot;b97-d&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;exchange\:.+?B97GGA.+?vdW.+?refit.+?correlation\:.+?</span><span class="se">\&quot;</span><span class="s2">.+?</span><span class="se">\&quot;</span><span class="s2">.+?</span><span class="se">\&quot;</span><span class="s2">.+?S\..+?Grimme\,.+?J\.Comput\..+?Chem\..+?27\,.+?\(2006\)\,.+?1787\-1799&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pbeh-3c&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;PBE0.+?modified.+?by.+?S\..+?Grimme.+?for.+?D3.+?and.+?gCP.+?exchange\:.+?PBE.+?\(kappa\=1\.0245\,.+?mu\=0\.12345679\).+?correlation\:.+?LDA.+?\(PW\).+?\+.+?PBE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;b97-3c&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;exchange\:.+?B97GGA.+?vdW.+?refit.+?correlation\:.+?</span><span class="se">\&quot;</span><span class="s2">.+?</span><span class="se">\&quot;</span><span class="s2">.+?</span><span class="se">\&quot;</span><span class="s2">.+?S\..+?Grimme\,.+?modifications.+?B97\-3c.+?\(2016\)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lh07t-svwn&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Lh07t\-SVWN.+?local.+?hybrid.+?functional.+?Local.+?hybrid.+?semi\-numerical.+?integral.+?thresholds\:.+?S\-junctions.+?\:.+?0\.10E\-05.+?P\-junctions.+?\:.+?0\.10E\-05&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lh07s-svwn&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Lh07s\-SVWN.+?local.+?hybrid.+?functional.+?Local.+?hybrid.+?semi\-numerical.+?integral.+?thresholds\:.+?S\-junctions.+?\:.+?0\.10E\-05.+?P\-junctions.+?\:.+?0\.10E\-05&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lh12ct-ssirpw92&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Lh12ct\-SsirPW92.+?local.+?hybrid.+?functional.+?Local.+?hybrid.+?semi\-numerical.+?integral.+?thresholds\:.+?S\-junctions.+?\:.+?0\.10E\-05.+?P\-junctions.+?\:.+?0\.10E\-05&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lh12ct-ssifpw92&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Lh12ct\-SsifPW92.+?local.+?hybrid.+?functional.+?Local.+?hybrid.+?semi\-numerical.+?integral.+?thresholds\:.+?S\-junctions.+?\:.+?0\.10E\-05.+?P\-junctions.+?\:.+?0\.10E\-05&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lh14t-calpbe&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Lh14t\-calPBE.+?local.+?hybrid.+?functional.+?Local.+?hybrid.+?semi\-numerical.+?integral.+?thresholds\:.+?S\-junctions.+?\:.+?0\.10E\-05.+?P\-junctions.+?\:.+?0\.10E\-05&quot;</span><span class="p">,</span>
    <span class="s2">&quot;b2-plyp&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Hybrid.+?part.+?of.+?B2\-PLYP.+?double.+?hybrid.+?functional.+?exchange\:.+?0\.47\(LDA.+?\+.+?Becke.+?\(B88\)\).+?\+.+?0\.53.+?HF.+?correlation\:.+?0\.73.+?LYP.+?\+.+?0\.27.+?PT2.+?\(MP2.+?program\).+?S\..+?Grimme\,.+?JCP.+?124\,.+?\(2006\)\,.+?034108\-16&quot;</span>
<span class="p">}</span>


<span class="c1"># type of xc functionals</span>
<span class="c1"># NB This should be updated if other standard xc functionals are added to TM.</span>
<span class="n">functional_types</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s-vwn&#39;</span><span class="p">:</span> <span class="s1">&#39;LDA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;s-vwn_Gaussian&#39;</span><span class="p">:</span> <span class="s1">&#39;LDA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pwlda&#39;</span><span class="p">:</span> <span class="s1">&#39;LDA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;b-lyp&#39;</span><span class="p">:</span> <span class="s1">&#39;GGA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;b-vwn&#39;</span><span class="p">:</span> <span class="s1">&#39;GGA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;b-p&#39;</span><span class="p">:</span> <span class="s1">&#39;GGA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pbe&#39;</span><span class="p">:</span> <span class="s1">&#39;GGA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tpss&#39;</span><span class="p">:</span> <span class="s1">&#39;MGGA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bh-lyp&#39;</span><span class="p">:</span> <span class="s1">&#39;HYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;b3-lyp&#39;</span><span class="p">:</span> <span class="s1">&#39;HYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;b3-lyp_Gaussian&#39;</span><span class="p">:</span> <span class="s1">&#39;HYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pbe0&#39;</span><span class="p">:</span> <span class="s1">&#39;HYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tpssh&#39;</span><span class="p">:</span> <span class="s1">&#39;MHYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pw6b95&#39;</span><span class="p">:</span> <span class="s1">&#39;MHYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;m06&#39;</span><span class="p">:</span> <span class="s1">&#39;MHYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;m06-l&#39;</span><span class="p">:</span> <span class="s1">&#39;MGGA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;m06-2x&#39;</span><span class="p">:</span> <span class="s1">&#39;MHYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lhf&#39;</span><span class="p">:</span> <span class="s1">&#39;ODFT&#39;</span><span class="p">,</span>
    <span class="s1">&#39;oep&#39;</span><span class="p">:</span> <span class="s1">&#39;ODFT&#39;</span><span class="p">,</span>
    <span class="s1">&#39;b97-d&#39;</span><span class="p">:</span> <span class="s1">&#39;GGA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pbeh-3c&#39;</span><span class="p">:</span> <span class="s1">&#39;HYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;b97-3c&#39;</span><span class="p">:</span> <span class="s1">&#39;GGA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lh07t-svwn&#39;</span><span class="p">:</span> <span class="s1">&#39;LHYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lh07s-svwn&#39;</span><span class="p">:</span> <span class="s1">&#39;LHYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lh12ct-ssirpw92&#39;</span><span class="p">:</span> <span class="s1">&#39;LHYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lh12ct-ssifpw92&#39;</span><span class="p">:</span> <span class="s1">&#39;LHYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lh14t-calpbe&#39;</span><span class="p">:</span> <span class="s1">&#39;LHYB&#39;</span><span class="p">,</span>
    <span class="s1">&#39;b2-plyp&#39;</span><span class="p">:</span> <span class="s1">&#39;DHYB&#39;</span>
<span class="p">}</span>


<div class="viewcode-block" id="convert_float"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.convert_float">[docs]</a><span class="k">def</span> <span class="nf">convert_float</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to convert a float from the output.</span>
<span class="sd">    Handles simple float and exponential notation with D and E</span>
<span class="sd">    (e.g 11.23 1.123E+01 1.123D+01).</span>
<span class="sd">    Returns None if the string is composed of only asterisks,</span>
<span class="sd">    as it might be in case of formatting problems in fortran.</span>

<span class="sd">    Args:</span>
<span class="sd">        f (str): the string to be converted to a float.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">asterisks_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">))</span></div>


<div class="viewcode-block" id="convert_int"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.convert_int">[docs]</a><span class="k">def</span> <span class="nf">convert_int</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to convert an int from the output.</span>
<span class="sd">    Returns None if the string is composed of only asterisks,</span>
<span class="sd">    as it might be in case of formatting problems in fortran.</span>

<span class="sd">    Args:</span>
<span class="sd">        i (str): the string to be converted to an int.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">asterisks_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert_time_string"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.convert_time_string">[docs]</a><span class="k">def</span> <span class="nf">convert_time_string</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to convert the string of the cpu and wall time given in the</span>
<span class="sd">    Turbomole outputs to seconds.</span>

<span class="sd">    Example: 2 days 1 hours 12 minutes and 55 seconds</span>

<span class="sd">    Args:</span>
<span class="sd">        l (str): the line with the timings.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: the value of the time in seconds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">split</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;days&quot;</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">86400</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;hours&quot;</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">3600</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;minutes&quot;</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">60</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;seconds&quot;</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">time</span></div>


<div class="viewcode-block" id="Parser"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser">[docs]</a><span class="k">class</span> <span class="nc">Parser</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main Parser object for Turbomole output files.</span>

<span class="sd">    This object allows to parse the different outputs (the stdout) produced by</span>
<span class="sd">    the Turbomole executables. Each method parses a specific portion of the output</span>
<span class="sd">    aiming at being as reusable as possible across the different types of outputs.</span>
<span class="sd">    The quantities are accessible as lazy properties, to avoid parsing the same</span>
<span class="sd">    sections multiple times.</span>
<span class="sd">    The parser expects the output of a completed calculation. Parsing of crashed</span>
<span class="sd">    calculations may lead to wrong output.</span>
<span class="sd">    The methods rely heavily on regex to select portions of the output and extract</span>
<span class="sd">    the quantities.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            string (str): the string of the output from Turbomole.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_string</span> <span class="o">=</span> <span class="n">string</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The string given as an input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_string</span>

<div class="viewcode-block" id="Parser.from_file"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.from_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">check_all_done</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates an instance from a file path.</span>

<span class="sd">        Args:</span>
<span class="sd">            filepath (str): path to the output file to read.</span>
<span class="sd">            check_all_done (bool): if True it will be checked that the job</span>
<span class="sd">                was &quot;all done&quot;. If not an exception is raised.</span>

<span class="sd">        Returns:</span>
<span class="sd">            an instance of Parser.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">string</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">string</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">check_all_done</span> <span class="ow">and</span> <span class="n">string</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;all done&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The string does not contain data for a completed calculation&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">string</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parser.all_done"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.all_done">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">all_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if &quot;all done&quot; is present in the string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;all done&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Parser.header"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.header">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The information contained in the header of the output, like the TM version and timings.</span>
<span class="sd">        Valid for all the TM executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;executable&quot; name, &quot;host&quot; of execution, &quot;tm_version&quot;, &quot;tm_build&quot;, &quot;start_time&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Example string parsed here:</span>
        <span class="c1">#  escf (node001) : TURBOMOLE V7.3 ( 22118 ) 1 Jul 2018 at 20:38:15</span>
        <span class="c1">#  Copyright (C) 2018 TURBOMOLE GmbH, Karlsruhe</span>
        <span class="c1">#    2018-11-13 09:30:15.283</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^.*?([\w]+)\s+\((.*?)\).*?TURBOMOLE(.*?)(\d</span><span class="si">{4}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2"> \d</span><span class="si">{2}</span><span class="s2">:\d</span><span class="si">{2}</span><span class="s2">:\d</span><span class="si">{2}</span><span class="s2">.\d</span><span class="si">{3}</span><span class="s2">)&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># the section of the version can miss some of the required information.</span>
        <span class="c1"># In this case turbomole version and build will be set to None.</span>
        <span class="c1"># For example it may be:</span>
        <span class="c1"># escf (node001) : TURBOMOLE rev. compiled 1 Jul 2018 at 20:38:15</span>
        <span class="n">r_version</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;V([\d\.]+\d)\s+.*&#39;</span>
        <span class="n">r_build</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;V[\d\.]+\d\s+\((.*)\)&#39;</span>
        <span class="n">match_version</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r_version</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="n">match_build</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r_build</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">match_version</span><span class="p">:</span>
            <span class="n">tm_version</span> <span class="o">=</span> <span class="n">match_version</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tm_version</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">match_build</span><span class="p">:</span>
            <span class="n">tm_build</span> <span class="o">=</span> <span class="n">match_build</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">or</span> <span class="kc">None</span>  <span class="c1"># When the build info inside the parenthesis is empty</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tm_build</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">executable</span><span class="o">=</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                 <span class="n">host</span><span class="o">=</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span>
                 <span class="n">tm_version</span><span class="o">=</span><span class="n">tm_version</span><span class="p">,</span>
                 <span class="n">tm_build</span><span class="o">=</span><span class="n">tm_build</span><span class="p">,</span>
                 <span class="n">start_time</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">date_format</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.centers"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.centers">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Center of mass and center of charge values.</span>
<span class="sd">        Valid for most of the TM executables (including the scf, escf, grad).</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;center_of_mass&quot; and &quot;center_of_charge&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">center_of_mass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center_of_charge</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;center of nuclear mass[\s:]*&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*(&quot;</span><span class="o">+</span><span class="n">float_number_re</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;)&quot;</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;center_of_mass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;center of nuclear charge[\s:]*&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*(&quot;</span><span class="o">+</span><span class="n">float_number_re</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;)&quot;</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;center_of_charge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.coordinates"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.coordinates">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Coordinates, species and charges of the atoms.</span>
<span class="sd">        Valid for most of the TM executables (including the scf, escf, grad).</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;coord&quot;, &quot;species&quot;, &quot;charges&quot;, and &quot;isotopes&quot; as lists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Example string parsed here:</span>
        <span class="c1">#               +--------------------------------------------------+</span>
        <span class="c1">#               | Atomic coordinate, charge and isotop information |</span>
        <span class="c1">#               +--------------------------------------------------+</span>
        <span class="c1">#</span>
        <span class="c1">#                     atomic coordinates            atom    charge  isotop</span>
        <span class="c1">#           0.00000000    0.00000000    1.00000000    h      1.000     0</span>
        <span class="c1">#           0.00000000    0.00000000   -1.00000000    h      1.000     0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;atomic coordinates\s+atom\s+charge\s+isotop\s+(.+?)\s+center of nuclear mass&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">species</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">isotopes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">split</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">convert_float</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">split</span><span class="p">[:</span><span class="mi">3</span><span class="p">]])</span>
            <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">charges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert_float</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>
            <span class="n">isotopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert_int</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">species</span><span class="o">=</span><span class="n">species</span><span class="p">,</span> <span class="n">charges</span><span class="o">=</span><span class="n">charges</span><span class="p">,</span> <span class="n">isotopes</span><span class="o">=</span><span class="n">isotopes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parser.basis"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.basis">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Data of the basis used for the calculation. Also the auxiliary base in</span>
<span class="sd">        case of RI.</span>
<span class="sd">        Valid for most of the TM executables (including the scf, escf, grad).</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;basis_per_specie&quot; a dict with species as keys and name of the</span>
<span class="sd">            basis as values, &quot;aux_basis_per_specie&quot; the same for auxiliary basis,</span>
<span class="sd">            &quot;number_scf_basis_func&quot; and &quot;number_scf_aux_basis_func&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See a test file as an example. Information parsed from the section starting with:</span>
        <span class="c1">#      +--------------------------------------------------+</span>
        <span class="c1">#      |               basis set information              |</span>
        <span class="c1">#      +--------------------------------------------------+</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;basis set information.*?symmetry group of the molecule&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">basis_string</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="c1"># takes the section:</span>
        <span class="c1">#    type   atoms  prim   cont   basis</span>
        <span class="c1">#    ---------------------------------------------------------------------------</span>
        <span class="c1">#     h        2     10      5   def-SV(P)   [2s1p|4s2p]</span>
        <span class="c1">#    ---------------------------------------------------------------------------</span>
        <span class="n">r_atoms</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;type   atoms  prim   cont   basis\s*-{5,}(.*?)-{5,}&quot;</span>

        <span class="n">match_atoms</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r_atoms</span><span class="p">,</span> <span class="n">basis_string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="n">basis_per_specie</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">match_atoms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match_atoms</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">l_split</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">basis_per_specie</span><span class="p">[</span><span class="n">l_split</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">l_split</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># For ridft can be present the section starting with &quot;RI-J AUXILIARY BASIS SET information&quot;.</span>
        <span class="n">r_atoms_aux</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;RI-J[K]? AUXILIARY BASIS SET.*?&quot;</span> <span class="o">+</span> <span class="n">r_atoms</span>

        <span class="n">match_atoms_aux</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r_atoms_aux</span><span class="p">,</span> <span class="n">basis_string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="n">aux_basis_per_specie</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">match_atoms_aux</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match_atoms_aux</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">l_split</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">aux_basis_per_specie</span><span class="p">[</span><span class="n">l_split</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">l_split</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># search the total number of basis function. This should be present at maximum two</span>
        <span class="c1"># one for the standard basis and one for the auxiliary.</span>
        <span class="n">list_n_basis_func</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;total number of SCF-basis functions[\s:]+?(\d+)&quot;</span><span class="p">,</span> <span class="n">basis_string</span><span class="p">)</span>

        <span class="n">len_n_basis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_n_basis_func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len_n_basis</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> instances of &#39;total number of SCF-basis functions&#39;, while &quot;</span>
                               <span class="s2">&quot;expecting at most 2.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">len_n_basis</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">len_n_basis</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">number_scf_basis_func</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">list_n_basis_func</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">number_scf_basis_func</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">len_n_basis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">number_scf_aux_basis_func</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">list_n_basis_func</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">number_scf_aux_basis_func</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">basis_per_specie</span><span class="o">=</span><span class="n">basis_per_specie</span><span class="p">,</span>
                 <span class="n">aux_basis_per_specie</span><span class="o">=</span><span class="n">aux_basis_per_specie</span><span class="p">,</span>
                 <span class="n">number_scf_basis_func</span><span class="o">=</span><span class="n">number_scf_basis_func</span><span class="p">,</span>
                 <span class="n">number_scf_aux_basis_func</span><span class="o">=</span><span class="n">number_scf_aux_basis_func</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.symmetry"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.symmetry">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information about the symmetry of the molecule and the irreducible representations.</span>
<span class="sd">        Valid for all the TM executables (in some case only a part of the information might</span>
<span class="sd">        be available).</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with symmetry &quot;symbol&quot;, &quot;n_reps&quot; and list of representation symbols &quot;reps&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">match_symm</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;symmetry group of the molecule[\s:]+?([\w]+)&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match_symm</span><span class="p">:</span>
            <span class="n">mol_sym_group</span> <span class="o">=</span> <span class="n">match_symm</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mol_sym_group</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Example: there are 4 real representations :   a1   a2   b1   b2</span>
        <span class="n">match_reps</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;there are\s+(\d+)\s+real representations&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match_reps</span><span class="p">:</span>
            <span class="n">n_reps</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">match_reps</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">match_reps</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;there are\s+\d+\s+real representations\s*:(\s+[\w\&#39;</span><span class="se">\&quot;</span><span class="s2">]+){&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n_reps</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;}&quot;</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match_reps</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not parse correctly the list of representations&quot;</span><span class="p">)</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="n">match_reps</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="n">n_reps</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_reps</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">mol_sym_group</span><span class="p">,</span> <span class="n">n_reps</span><span class="p">,</span> <span class="n">reps</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">symbol</span><span class="o">=</span><span class="n">mol_sym_group</span><span class="p">,</span>
                 <span class="n">n_reps</span><span class="o">=</span><span class="n">n_reps</span><span class="p">,</span>
                 <span class="n">reps</span><span class="o">=</span><span class="n">reps</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.cosmo_header"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.cosmo_header">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">cosmo_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information from the header of the cosmo section (area and volume)</span>
<span class="sd">        when cosmo is activated. Valid for scf and escf/egrad.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;area&quot; and &quot;volume&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See a test file as an example. Selects the section of the cosmo header starting with:</span>
        <span class="c1"># ==============================================================================</span>
        <span class="c1">#                       COSMO switched on</span>
        <span class="c1"># ==============================================================================</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;COSMO switched on.*?(---)+&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">volume</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;area&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;volume&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;volume&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.density_functional_data"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.density_functional_data">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">density_functional_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information relative to DFT calculations (xf functional and grids).</span>
<span class="sd">        Valid for scf, gradient and relax executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with the full string describing the functional &quot;functional_msg&quot;,</span>
<span class="sd">            &quot;functional_name&quot;, &quot;functional_type&quot;, the version of &quot;xcfun&quot;,</span>
<span class="sd">            &quot;spherical_gridsize, number of &quot;gridpoints&quot; for spherical integration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See a test file as an example. Selects the section of dft information starting with:</span>
        <span class="c1">#           ------------------</span>
        <span class="c1">#           density functional</span>
        <span class="c1">#           ------------------</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;density functional[\s]*?-{5,}.*?(biggest|-{5,})&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">dft_string</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">functional_msg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">functional_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">functional_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">xcfun</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">spherical_gridsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">gridpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># capture the part with the message describing the xc functional.</span>
        <span class="c1"># &quot;iterations will be done with small grid&quot; is present only for modified grids (e.g. m3)</span>
        <span class="n">r_func</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;--\s+(.*?)\s*(iterations will be done with small grid|spherical integration)&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;USE AT YOUR OWN RISK&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dft_string</span><span class="p">:</span>
            <span class="n">func_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r_func</span><span class="p">,</span> <span class="n">dft_string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

            <span class="c1"># Matches the type of functional based on the message produced by TM.</span>
            <span class="c1"># The messages have been extracted for all the standard types available</span>
            <span class="c1"># in define. Notice that if further xc functional need be parsed, the</span>
            <span class="c1"># functional_strings dictionary should be updated accordingly.</span>
            <span class="c1"># Also arbitrary mix will be ignored (when &quot;USE AT YOUR OWN RISK&quot; is present).</span>
            <span class="k">if</span> <span class="n">func_match</span><span class="p">:</span>
                <span class="n">func_msg</span> <span class="o">=</span> <span class="n">func_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;functional_msg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_msg</span>

                <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">functional_strings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">func_msg</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">):</span>
                        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;functional_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_name</span>
                        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;functional_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">functional_types</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span>
                        <span class="k">break</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">dft_string</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;XCFun&quot;</span> <span class="ow">in</span> <span class="n">l</span> <span class="ow">and</span> <span class="s2">&quot;version&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;xcfun&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;spherical gridsize&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;spherical_gridsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;i.e. gridpoints&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;gridpoints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.rij_info"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.rij_info">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">rij_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information about RI. Valid for ridft and escf/egrad.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;marij&quot; to True if marij calculation, &quot;rij_memory&quot;, &quot;rik&quot; to True if $rik</span>
<span class="sd">            and &quot;ricore&quot; memory in MB.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parses the section that can start with RI, RI-J or RI-JK</span>
        <span class="c1">#            ------------------------</span>
        <span class="c1">#                RI-JK - INFORMATION</span>
        <span class="c1">#            ------------------------</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;RI[\-JK]* - INFORMATION.*?Memory allocated for.*?$&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">match_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">marij</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">rij_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">rik</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">ricore</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match_str</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;Multipole Accelerated RI-J&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;marij&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># stopping at &quot;RI&quot; should match the line for both ridft and escf</span>
            <span class="k">if</span> <span class="s2">&quot;Memory allocated for RI&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;rij_memory&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">match_rik_1</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;BLOCKING OF .*?MOS FOR RI-K&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="c1"># ridft</span>
        <span class="n">match_rik_2</span> <span class="o">=</span> <span class="s2">&quot;FOUND RI-K FLAG&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="c1"># escf</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;rik&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_rik_1</span> <span class="ow">or</span> <span class="n">match_rik_2</span>

        <span class="c1"># ricore in ridft (is in another section)</span>
        <span class="n">r_ricore</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Allocatable memory for RI due to \$ricore \(MB\):\s+(\d+)&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r_ricore</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;ricore&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ricore in escf</span>
            <span class="n">r_ricore</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Core memory available \(ricore\)\s+(\d+)&quot;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r_ricore</span><span class="p">,</span> <span class="n">match_str</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;ricore&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.dftd"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.dftd">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">dftd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information about dispersion correction in dft.</span>
<span class="sd">        Valid for scf executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with the type of &quot;correction&quot; (string) and the value of correction &quot;en_corr&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># assume that the DFT-D part is between these two sections</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;nuclear repulsion energy(.*?)-S,T\+V- integrals&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">match_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;DFT-D&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">match_str</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">correction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">en_corr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># The output changes depending on the type of correction. Is not always mentioned.</span>
        <span class="c1"># For D1 and D2 should be deduced from the value of the damping.</span>
        <span class="k">if</span> <span class="s2">&quot;DFT-D V3(BJ)&quot;</span> <span class="ow">in</span> <span class="n">match_str</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;correction&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;D3-BJ&quot;</span>
        <span class="k">elif</span> <span class="s2">&quot;DFT-D V3&quot;</span> <span class="ow">in</span> <span class="n">match_str</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;correction&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;D3&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">damp_l</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;exponent of damping function \(d\)\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">damp_l</span><span class="p">:</span>
                <span class="n">damp_val</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">damp_l</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">damp_val</span> <span class="o">==</span> <span class="mi">20</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="s2">&quot;correction&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;D2&quot;</span>
                <span class="k">elif</span> <span class="n">damp_val</span> <span class="o">==</span> <span class="mi">23</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="s2">&quot;correction&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;D1&quot;</span>

        <span class="n">corr_l</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;empirical dispersive energy correction[\s=]+(&quot;</span> <span class="o">+</span> <span class="n">float_number_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">corr_l</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;en_corr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">corr_l</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.pre_scf_run"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.pre_scf_run">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">pre_scf_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information extracted about the scf calculation printed before running</span>
<span class="sd">        the scf loop. Valid only for scf executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;diis&quot; True if activated, diis_error_vect&quot;, &quot;conv_tot_en&quot;, &quot;conv_one_e_en&quot;,</span>
<span class="sd">            &quot;virtual_orbital_shift_on&quot;, &quot;virtual_orbital_shift_limit&quot;, &quot;orbital_characterization&quot;,</span>
<span class="sd">            &quot;restart_file&quot;, &quot;n_occupied_orbitals&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># large portion to include several sections</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;basis set information(.*?)ITERATION  ENERGY&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">match_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">diis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">diis_error_vect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">conv_tot_en</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">conv_one_e_en</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">virtual_orbital_shift_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">virtual_orbital_shift_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">orbital_characterization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">restart_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_occupied_orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># analyze the string line by line to find those corresponding to the values to parse.</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match_str</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;DIIS switched on&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;diis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;diis_error_vect&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;increment of total energy&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;conv_tot_en&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;increment of one-electron energy&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;conv_one_e_en&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;automatic virtual orbital shift switched on&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;virtual_orbital_shift_on&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="s2">&quot;shift if e(lumo)-e(homo)&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;virtual_orbital_shift_limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;orbital characterization&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;orbital_characterization&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;DSCF restart information will be dumped onto file&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;restart_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;number of occupied orbitals&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;n_occupied_orbitals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.scf_iterations"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.scf_iterations">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">scf_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Data for each iteration of the scf loop.</span>
<span class="sd">        Valid only for scf executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with the list of values extracted for each scf step &quot;energies&quot;, &quot;dampings&quot;.</span>
<span class="sd">            The value of the &quot;first_index&quot; and &quot;n_steps&quot;. &quot;converged&quot; True if the calculation is converged.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># parsing an iteration of a block like:</span>
        <span class="c1">#                                               current damping :  0.700</span>
        <span class="c1">#  ITERATION  ENERGY          1e-ENERGY        2e-ENERGY     RMS[dD(SAO)]   TOL</span>
        <span class="c1">#    1  -76.143808666911    -124.43866883     38.987705388    0.000D+00 0.175D-08</span>

        <span class="n">std_float</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_re</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="n">d_float</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_d_re</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^\s*(\d+)&quot;</span> <span class="o">+</span> <span class="n">std_float</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="n">d_float</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;\s*$&quot;</span>

        <span class="n">match_l</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match_l</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">iter_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match_l</span><span class="p">:</span>
            <span class="n">iter_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert_int</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># dscf has a &quot;:&quot; while ridft as a &quot;=&quot;</span>
        <span class="n">dampings</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;current damping[\s:=]+&quot;</span><span class="o">+</span><span class="n">std_float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dampings</span><span class="p">:</span>
            <span class="n">dampings</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dampings</span><span class="p">]</span>

        <span class="n">converged</span> <span class="o">=</span> <span class="s2">&quot;convergence criteria satisfied after &quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">energies</span><span class="o">=</span><span class="n">energies</span><span class="p">,</span>
                 <span class="n">first_index</span><span class="o">=</span><span class="n">iter_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                 <span class="n">n_steps</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">iter_indices</span><span class="p">),</span>
                 <span class="n">dampings</span><span class="o">=</span><span class="n">dampings</span><span class="p">,</span>
                 <span class="n">converged</span><span class="o">=</span><span class="n">converged</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.scf_energies"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.scf_energies">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">scf_energies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Final energies for scf calculation.</span>
<span class="sd">        Valid only for scf executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with the energy and its contributions: &quot;total_energy&quot;, &quot;kinetic_energy&quot;,</span>
<span class="sd">            &quot;potential_energy&quot;, &quot;virial_theorem&quot;, &quot;wavefunction_norm&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parsing the section:</span>
        <span class="c1">#              ------------------------------------------</span>
        <span class="c1">#              |  total energy      =    -76.34276215784  |</span>
        <span class="c1">#              ------------------------------------------</span>
        <span class="c1">#              :  kinetic energy    =     75.98641545802  :</span>
        <span class="c1">#              :  potential energy  =   -152.32917761586  :</span>
        <span class="c1">#              :  virial theorem    =      1.99533227919  :</span>
        <span class="c1">#              :  wavefunction norm =      1.00000000000  :</span>
        <span class="c1">#              ..........................................</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\|\s+total energy(.*?)\.{3,}&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">total_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">kinetic_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">potential_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">virial_theorem</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">wavefunction_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">))</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.riper_scf_energies"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.riper_scf_energies">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">riper_scf_energies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Final energies for scf calculation with riper executable.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with the energy and its contributions: &quot;total_energy&quot;, &quot;kinetic_energy&quot;,</span>
<span class="sd">            &quot;coulomb_energy&quot;, &quot;xc_energy&quot;, &quot;ts_energy&quot;, &quot;free_energy&quot;</span>
<span class="sd">            and &quot;sigma0_energy&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parsing the section:</span>
        <span class="c1">#               +--------------------------------------------------+</span>
        <span class="c1">#               |                FINAL ENERGIES                    |</span>
        <span class="c1">#               +--------------------------------------------------+</span>
        <span class="c1">#               | KINETIC ENERGY       =          75.3219906303    |</span>
        <span class="c1">#               | COULOMB ENERGY       =        -140.6650084669    |</span>
        <span class="c1">#               | EXCH. &amp; CORR. ENERGY =         -10.8758949666    |</span>
        <span class="c1">#               |==================================================|</span>
        <span class="c1">#               | TOTAL ENERGY         =         -76.2189128032    |</span>
        <span class="c1">#               | T*S                  =          -0.0000000000    |</span>
        <span class="c1">#               | FREE  ENERGY         =         -76.2189128032    |</span>
        <span class="c1">#               | ENERGY (sigma-&gt;0)    =         -76.2189128032    |</span>
        <span class="c1">#               +--------------------------------------------------+</span>

        <span class="c1"># Note that &quot;FINAL ENERGIES&quot; is needed here because the rest of the table is also</span>
        <span class="c1"># provided for each scf iteration.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;FINAL ENERGIES\s+\|\s+\+-{50,}\+\s+\|\s+KINETIC ENERGY(.*?)\+-{50,}\+&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">total_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">kinetic_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">coulomb_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">xc_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ts_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">free_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sigma0_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s1">&#39;KINETIC ENERGY&#39;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;kinetic_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s1">&#39;COULOMB ENERGY&#39;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;coulomb_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s1">&#39;EXCH. &amp; CORR. ENERGY&#39;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;xc_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s1">&#39;TOTAL ENERGY&#39;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;total_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s1">&#39;T*S&#39;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ts_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s1">&#39;FREE  ENERGY&#39;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;free_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s1">&#39;ENERGY (sigma-&gt;0)&#39;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;sigma0_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.cosmo_results"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.cosmo_results">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">cosmo_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Results of cosmo.</span>
<span class="sd">        Valid only for scf executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with several subdictionaries: &quot;parameters&quot; (&quot;nppa&quot;, &quot;nspa&quot;, &quot;nsph&quot;, &quot;npspher&quot;, &quot;disex&quot;, &quot;disex2&quot;,</span>
<span class="sd">            &quot;rsolv&quot;, &quot;routf&quot;, &quot;phsran&quot;, &quot;ampran&quot;, &quot;cavity&quot;, &quot;epsilon&quot;, &quot;refind&quot;, &quot;fepsi&quot;), &quot;screening_charge&quot;</span>
<span class="sd">            (&quot;cosmo&quot;, &quot;correction&quot;, &quot;total&quot;), &quot;energies&quot; (&quot;total_energy&quot;, &quot;total_energy_oc_corr&quot;,</span>
<span class="sd">            &quot;dielectric_energy&quot;, &quot;dielectric_energy_oc_corr&quot;), &quot;element_radius&quot; (&quot;radius, &quot;sites&quot;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See test file for an example. Parses the section starting with:</span>
        <span class="c1">#  ==============================================================================</span>
        <span class="c1">#                                   COSMO RESULTS</span>
        <span class="c1">#  ==============================================================================</span>
        <span class="c1"># and splits in block for the section &quot;CAVITY VOLUME/AREA&quot;, &quot;SCREENING CHARGE&quot;, &quot;ENERGIES&quot;, &quot;ELEMENT RADIUS&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;COSMO RESULTS\s*(===)+.*?PARAMETER:(.*?)CAVITY VOLUME/AREA(.*?)SCREENING CHARGE:(.*?)ENERGIES(.*?)ELEMENT RADIUS \[A\]: ATOM LIST(.*?)(===)+&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># In this section a list of keyword_name: value are parsed, one for each line.</span>
        <span class="c1"># this dictionary allows to loop over all the lines and cast the value to the</span>
        <span class="c1"># correct type.</span>
        <span class="n">key_types_parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">nppa</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                                    <span class="n">nspa</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                                    <span class="n">nsph</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                                    <span class="n">nps</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                                    <span class="n">npspher</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                                    <span class="n">disex</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                                    <span class="n">disex2</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                                    <span class="n">rsolv</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                                    <span class="n">routf</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                                    <span class="n">phsran</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                                    <span class="n">ampran</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                                    <span class="n">cavity</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                                    <span class="n">epsilon</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                                    <span class="n">refind</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                                    <span class="n">fepsi</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">d_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key_types_parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">key_types_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># NB here the regex is tailored to explicitly capture the string that</span>
                <span class="c1"># need to be parsed. For example:</span>
                <span class="c1"># disex2: 3538.50</span>
                <span class="c1"># rsolv [A]: 1.3000</span>
                <span class="c1"># if more are added the regex may need an update.</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;[\s\[A\]]*:&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
                    <span class="n">d_parameters</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">break</span>

        <span class="n">d_screening</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cosmo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">correction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">total</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;cosmo&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d_screening</span><span class="p">[</span><span class="s2">&quot;cosmo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;correction&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d_screening</span><span class="p">[</span><span class="s2">&quot;correction&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;total&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d_screening</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">d_energies</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">total_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">total_energy_oc_corr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">dielectric_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">dielectric_energy_oc_corr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Total energy\s*=&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">d_energies</span><span class="p">[</span><span class="s2">&quot;total_energy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Total energy \+ OC corr\.\s*=&quot;</span><span class="p">,</span><span class="n">l</span><span class="p">):</span>
                <span class="n">d_energies</span><span class="p">[</span><span class="s2">&quot;total_energy_oc_corr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Dielectric energy\s*=&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">d_energies</span><span class="p">[</span><span class="s2">&quot;dielectric_energy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Diel\. energy \+ OC corr\.\s+=&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">d_energies</span><span class="p">[</span><span class="s2">&quot;dielectric_energy_oc_corr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">d_element_radius</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="n">split</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="c1"># list of sites are separated by &quot;,&quot; and can be defined as intervals with &quot;-&quot;</span>
            <span class="c1"># example: 1,3-5,7</span>
            <span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">split</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="s2">&quot;-&quot;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="n">sites_split</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
                    <span class="n">sites</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">convert_int</span><span class="p">(</span><span class="n">sites_split</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">sites_split</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert_int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="n">d_element_radius</span><span class="p">[</span><span class="n">split</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)),</span>
                                          <span class="s2">&quot;sites&quot;</span><span class="p">:</span> <span class="n">sites</span><span class="p">}</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">d_parameters</span><span class="p">,</span> <span class="n">screening_charge</span><span class="o">=</span><span class="n">d_screening</span><span class="p">,</span>
                 <span class="n">energies</span><span class="o">=</span><span class="n">d_energies</span><span class="p">,</span> <span class="n">element_radius</span><span class="o">=</span><span class="n">d_element_radius</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.electrostatic_moments"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.electrostatic_moments">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">electrostatic_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information about the electrostatic moment (dipole and quadrupole).</span>
<span class="sd">        Valid only for scf executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with single &quot;dipole&quot; and &quot;quadrupole&quot; moments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See test files for an example. Parses the section starting with:</span>
        <span class="c1">#  ==============================================================================</span>
        <span class="c1">#                            electrostatic moments</span>
        <span class="c1">#  ==============================================================================</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;electrostatic moments\s*(==)+.*?charge\s*-+(.*?)-+\s*dipole moment(.*?)&quot;</span> \
            <span class="sa">r</span><span class="s2">&quot;quadrupole moment(.*?anisotropy=\s*&quot;</span> <span class="o">+</span> <span class="n">float_number_all_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span>
        <span class="c1"># does not stop at &quot;============&quot; since there might be the PABOON section before that.</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;unrestricted_electrons&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="s2">&quot;a-b&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;unrestricted_electrons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;charge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">dipole</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">d_dipole</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot; x &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">dipole</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot; y &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">dipole</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot; z &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">dipole</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;| dipole moment |&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d_dipole</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">5</span><span class="p">])</span>

        <span class="n">d_dipole</span><span class="p">[</span><span class="s2">&quot;moment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dipole</span>

        <span class="n">quadrupole</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">d_quadrupole</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot; xx &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot; yy &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot; zz &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot; xy &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">quadrupole</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot; xz &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">quadrupole</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot; yz &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">quadrupole</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;trace=&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d_quadrupole</span><span class="p">[</span><span class="s2">&quot;trace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;anisotropy&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d_quadrupole</span><span class="p">[</span><span class="s2">&quot;anisotropy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">d_quadrupole</span><span class="p">[</span><span class="s2">&quot;moment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quadrupole</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;dipole&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_dipole</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;quadrupole&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_quadrupole</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.timings"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.timings">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">timings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cpu and wall time for the calculation.</span>
<span class="sd">        Valid for all the Turbomole executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;cpu_time&quot; and &quot;wall_time&quot; in seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#          total  cpu-time :   0.74 seconds</span>
        <span class="c1">#          total wall-time :   0.79 seconds</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(total\s+cpu-time.*?)(\d</span><span class="si">{4}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2"> \d</span><span class="si">{2}</span><span class="s2">:\d</span><span class="si">{2}</span><span class="s2">:\d</span><span class="si">{2}</span><span class="s2">.\d</span><span class="si">{3}</span><span class="s2">)&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cpu_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">wall_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">end_time</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">date_format</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;cpu-time&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;cpu_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_time_string</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;wall-time&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;wall_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_time_string</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.s2"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.s2">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">s2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Value S^2 of the spin.</span>
<span class="sd">        Valid only for scf executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict containing &quot;s2&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parsing:  &lt;S*S&gt;     0.75205422</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&lt;S\*S&gt;\s+?(&quot;</span> <span class="o">+</span> <span class="n">float_number_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;s2&quot;</span><span class="p">:</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))}</span></div>

<div class="viewcode-block" id="Parser.is_uhf"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.is_uhf">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">is_uhf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if UHF calculation.</span>
<span class="sd">        Valid for scf, gradient and escf executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># &quot;mode&quot; appears in dscf and escf, while &quot;modus&quot; in ridft and grad.</span>
        <span class="n">is_uhf</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;UHF (mode|modus) switched on&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">is_uhf</span></div>

<div class="viewcode-block" id="Parser.fermi"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.fermi">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">fermi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information about smearing of occupations.</span>
<span class="sd">        Valid only for scf executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;initial_elec_temp&quot;, &quot;final_elec_temp&quot;, &quot;annealing_homo_lumo_gap_limit&quot;,</span>
<span class="sd">            &quot;smearing_de_limit&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># parses the section:</span>
        <span class="c1">#     Fermi smearing switched on</span>
        <span class="c1">#       Initial electron temperature:   500.00</span>
        <span class="c1">#         Final electron temperature:    50.00</span>
        <span class="c1">#                   Annealing factor:    0.900</span>
        <span class="c1">#        Annealing if HOMO-LUMO gap &lt;  0.2E+00</span>
        <span class="c1">#       Smearing switched off if DE &lt;  0.1E-02</span>

        <span class="c1"># this shows up before the start of the scf iterations. Since the beginning of that</span>
        <span class="c1"># may change (at least depending if it&#39;s a new calculation or a restart)</span>
        <span class="c1"># the end of the regex is on the last line and the value.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Fermi smearing switched on.*?Smearing switched off if DE\s+&lt;\s+&quot;</span> <span class="o">+</span> <span class="n">float_number_e_re</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">initial_elec_temp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">final_elec_temp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">annealing_homo_lumo_gap_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">smearing_de_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;Initial electron temperature&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;initial_elec_temp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;Final electron temperature&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;final_elec_temp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;Annealing factor&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;annealing_factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;Annealing if HOMO-LUMO gap&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;annealing_homo_lumo_gap_limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;Smearing switched off if DE&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;smearing_de_limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.integral"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.integral">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">integral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Thresholds for integrals.</span>
<span class="sd">        Valid for scf, gradient and escf executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;integral_neglect_threshold&quot;, &quot;thize&quot;, &quot;thime&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># parses the section</span>
        <span class="c1">#  integral neglect threshold       :  0.18E-08</span>
        <span class="c1">#  integral storage threshold THIZE :  0.10E-04</span>
        <span class="c1">#  integral storage threshold THIME :         5</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">integral_neglect_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">thize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">thime</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;integral neglect threshold.*?$&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;integral_neglect_threshold&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;integral storage threshold THIZE.*?$&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;thize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;integral storage threshold THIME.*?$&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;thime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.pre_escf_run"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.pre_escf_run">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">pre_escf_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information extracted about the escf calculation printed before running</span>
<span class="sd">        the escf iterations. Valid for escf and egrad executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;calc_type&quot;, &quot;residuum_convergence_criterium&quot;, &quot;n_occupied_orbitals&quot;,</span>
<span class="sd">            &quot;orbital_characterization&quot;, &quot;max_davidson_iter&quot;, &quot;machine_precision&quot;, &quot;max_core_mem&quot;,</span>
<span class="sd">            &quot;max_cao_basis_vectors&quot;, &quot;max_treated_vectors&quot;, &quot;irrep_data&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See test files for examples. The values spread over a relatively large number of lines</span>
        <span class="c1"># and the lines are matched individually.</span>

        <span class="c1"># large portion of the code considered to accomodate the various pieces of information.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;basis set information.+Iteration\s+IRREP\s+Converged&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">match_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">calc_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">residuum_convergence_criterium</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_occupied_orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">orbital_characterization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_davidson_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">machine_precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_core_mem</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_cao_basis_vectors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_treated_vectors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">irrep_data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^(.*)[\-\s]CALCULATION\s+&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;calc_type&quot;</span><span class="p">]</span> <span class="o">=</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;residuum convergence criterium.*?$&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;residuum_convergence_criterium&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;number of occupied orbitals.*?$&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;n_occupied_orbitals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;orbital characterization.*?$&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;orbital_characterization&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;maximum number of Davidson iterations set to.*?$&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;max_davidson_iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;machine precision.*?$&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">,</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;machine_precision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;maximum core memory set to.*?$&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;max_core_mem&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;corresponding to\s+(\d+)\s+vectors in CAO basis&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;max_cao_basis_vectors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;maximum number of simultaneously treated vectors.*?$&quot;</span><span class="p">,</span> <span class="n">match_str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;max_treated_vectors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;IRREP\s+tensor\s+space\s+dimension\s+number\s+of\s+roots(.+)maximum number of Davidson&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">match_str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">irrep_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">split</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">irrep_data</span><span class="p">[</span><span class="n">split</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tensor_space_dim&#39;</span><span class="p">:</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="s1">&#39;n_roots&#39;</span><span class="p">:</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="mi">2</span><span class="p">])}</span>

            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;irrep_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">irrep_data</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.escf_iterations"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.escf_iterations">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">escf_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Data for each iteration of the escf loop.</span>
<span class="sd">        Valid for escf and egrad executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict &quot;converged&quot; to True if the calculation is converged and a list of &quot;steps&quot;. One element of the list for</span>
<span class="sd">                each escf step. One element of the sublist for each irrep. The inner list contains the convergence information:</span>
<span class="sd">                [name of the irrep, number of converged roots, euclidean residual norm].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># splits the different iterations, parsing the section starting with</span>
        <span class="c1">#  Iteration IRREP Converged      Max. Euclidean</span>
        <span class="c1">#                  roots          residual norm</span>
        <span class="c1">#</span>
        <span class="c1">#     1       a1       0        3.367862225107080D-01</span>
        <span class="c1">#             a2       9        6.722471267583007D-14</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Iteration\s+IRREP\s+Converged\s+Max\.\s+Euclidean\s+roots\s+residual\s+norm\s+(.*?)(converged|Warning)&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">iter_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">convert_line</span><span class="p">(</span><span class="n">ls</span><span class="p">):</span>
            <span class="n">ls</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">ls</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ls</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">ls</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">ls</span>

        <span class="n">iter_steps_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">iter_step</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">iter_str</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">split</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iter_step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">iter_steps_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_step</span><span class="p">)</span>
                <span class="n">iter_step</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_line</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">iter_step</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert_line</span><span class="p">(</span><span class="n">split</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;wrong line </span><span class="si">{}</span><span class="s2"> in escf iterations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">iter_step</span><span class="p">:</span>
            <span class="n">iter_steps_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_step</span><span class="p">)</span>

        <span class="n">converged</span> <span class="o">=</span> <span class="s2">&quot;converged&quot;</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="n">iter_steps_list</span><span class="p">,</span>
                 <span class="n">converged</span><span class="o">=</span><span class="n">converged</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Parser.escf_gs_total_en"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.escf_gs_total_en">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">escf_gs_total_en</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Value of the final total energy of escf.</span>
<span class="sd">        Valid for escf and egrad executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parses:</span>
        <span class="c1">#                             Ground state</span>
        <span class="c1">#  Total energy:                           -76.34301407423000</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Ground\s+state\s+Total\s+energy:\s+(&quot;</span><span class="o">+</span><span class="n">float_number_re</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;)&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Parser.escf_excitations"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.escf_excitations">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">escf_excitations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All the values for each calculated excitation.</span>
<span class="sd">        Valid for escf and egrad executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with name of irreps as keywords and list of excitations as values. For each excitation</span>
<span class="sd">            a dict with: &quot;tot_en&quot;, &quot;osc_stre&quot;, &quot;rot_stre&quot;, &quot;dominant_contributions&quot; (list of contributions),</span>
<span class="sd">            &quot;moments_columns&quot; (list of dicts value of electric and magnetic moment for each column).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See test files for example. Splits the sections for each irrep delimited by</span>
        <span class="c1">#  ==============================================================================</span>
        <span class="c1">#</span>
        <span class="c1">#                               I R R E P   a1</span>
        <span class="c1">#</span>
        <span class="c1">#  ==============================================================================</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;={3,}\s+I R R E P\s+[&quot;</span><span class="o">+</span> <span class="n">irrep_re_group</span> <span class="o">+</span><span class="sa">r</span><span class="s2">&quot;]+\s+={3,}.*?(?=={3,}|SUMMARY|-{5,})&quot;</span>

        <span class="n">match_irreps</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match_irreps</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Compile the regex beforehand since they will be executed several times.</span>

        <span class="c1"># Splits the excitations for each irrep. For example a group starting with:</span>
        <span class="c1">#                          1 singlet a1 excitation</span>
        <span class="n">exc_head_group</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^\s+\d+\s+(?:singlet\s+|triplet\s+|)[&quot;</span> <span class="o">+</span> <span class="n">irrep_re_group</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;]+?\s+excitation&quot;</span>
        <span class="n">r_excited</span> <span class="o">=</span> <span class="n">exc_head_group</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;.*?(?=&quot;</span> <span class="o">+</span> <span class="n">exc_head_group</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;|\Z)&quot;</span>
        <span class="n">regex_excited</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">r_excited</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

        <span class="c1"># Finds the value of the total energy</span>
        <span class="n">r_tot_en</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Total energy:\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_all_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span>
        <span class="n">regex_tot_en</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">r_tot_en</span><span class="p">)</span>

        <span class="c1"># Parses:</span>
        <span class="c1">#  Oscillator strength:</span>
        <span class="c1">#     velocity representation:             0.1689055727340166</span>
        <span class="c1">#     length representation:               0.7845154315911747E-01</span>
        <span class="c1">#     mixed representation:                0.1151125659046751</span>
        <span class="n">r_osc</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Oscillator strength.*?length representation:\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_all_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span>
        <span class="n">regex_osc</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">r_osc</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="c1"># Parses:</span>
        <span class="c1">#  Rotatory strength:</span>
        <span class="c1">#     velocity representation:              0.000000000000000</span>
        <span class="c1">#     velocity rep. / 10^(-40)erg*cm^3:     0.000000000000000</span>
        <span class="c1">#     length representation:                0.000000000000000</span>
        <span class="c1">#     length rep. / 10^(-40)erg*cm^3:       0.000000000000000</span>
        <span class="n">r_rot</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Rotatory strength.*?length representation:\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_all_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span>
        <span class="n">regex_rot</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">r_rot</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="c1"># Parses the dominant contributions. Example:</span>
        <span class="c1">#  Dominant contributions:</span>
        <span class="c1">#       occ. orbital   energy / eV   virt. orbital     energy / eV   |coeff.|^2*100</span>
        <span class="c1">#         3 a1             -8.44           4 a1              0.92       99.2</span>
        <span class="c1">#</span>
        <span class="c1"># Different points to stop depending on singlet, triplet or uhf.</span>
        <span class="n">r_dom_contrib</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Dominant contributions:\s+.*?coeff\.\|\^2\*100\s+(.*?)(?=Change of electron number|&lt;|S\^2|1st)&quot;</span>
        <span class="n">regex_dom_contrib</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">r_dom_contrib</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

        <span class="c1"># The following parse the section with the electric and magnetic moments</span>
        <span class="n">r_elec_dip</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Electric transition dipole moment \(length rep\.\):(.*?)Magnetic transition&quot;</span>
        <span class="n">regec_elec_dip</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">r_elec_dip</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="n">r_mag_dip</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Magnetic transition dipole moment / i:(.*?)Electric quadrupole&quot;</span>
        <span class="n">regec_mag_dip</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">r_mag_dip</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="n">r_elec_quad</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Electric quadrupole transition moment:(.*)&quot;</span>
        <span class="n">regec_elec_quad</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">r_elec_quad</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="n">excited_data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">irrep_group</span> <span class="ow">in</span> <span class="n">match_irreps</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;I R R E P\s+([&quot;</span> <span class="o">+</span> <span class="n">irrep_re_group</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;]+)&quot;</span>
            <span class="n">irrep</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">irrep_group</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">match_excitations</span> <span class="o">=</span> <span class="n">regex_excited</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">irrep_group</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match_excitations</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not extract the single excitation contributions&quot;</span><span class="p">)</span>

            <span class="n">single_excitations_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># loop over the excitations</span>
            <span class="k">for</span> <span class="n">exc_group</span> <span class="ow">in</span> <span class="n">match_excitations</span><span class="p">:</span>
                <span class="n">exc_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tot_en</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">osc_stre</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">rot_stre</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">dominant_contributions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">moments_columns</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

                <span class="n">match_tot_en</span> <span class="o">=</span> <span class="n">regex_tot_en</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">exc_group</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match_tot_en</span><span class="p">:</span>
                    <span class="n">exc_data</span><span class="p">[</span><span class="s2">&quot;tot_en&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match_tot_en</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

                <span class="n">match_osc_stre</span> <span class="o">=</span> <span class="n">regex_osc</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">exc_group</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match_osc_stre</span><span class="p">:</span>
                    <span class="n">exc_data</span><span class="p">[</span><span class="s2">&quot;osc_stre&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match_osc_stre</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

                <span class="n">match_rot_stre</span> <span class="o">=</span> <span class="n">regex_rot</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">exc_group</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match_rot_stre</span><span class="p">:</span>
                    <span class="n">exc_data</span><span class="p">[</span><span class="s2">&quot;rot_stre&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match_rot_stre</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

                <span class="n">match_dominant</span> <span class="o">=</span> <span class="n">regex_dom_contrib</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">exc_group</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match_dominant</span><span class="p">:</span>
                    <span class="n">dominant_contributions</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c1"># loop over dominant contributions to the excitation</span>
                    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match_dominant</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="c1"># there could be 7 or 9 columns depending if it is a rhf or uhf, respectively.</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                            <span class="n">occ_orb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">convert_int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">irrep</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">energy</span><span class="o">=</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">spin</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                            <span class="n">virt_orb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">convert_int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">irrep</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">energy</span><span class="o">=</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span> <span class="n">spin</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                            <span class="n">dominant_contributions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">occ_orb</span><span class="o">=</span><span class="n">occ_orb</span><span class="p">,</span> <span class="n">virt_orb</span><span class="o">=</span><span class="n">virt_orb</span><span class="p">,</span>
                                                               <span class="n">coeff</span><span class="o">=</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="p">])))</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
                            <span class="n">occ_orb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">convert_int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">irrep</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">energy</span><span class="o">=</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">spin</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                            <span class="n">virt_orb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">convert_int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">irrep</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">energy</span><span class="o">=</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">7</span><span class="p">]),</span> <span class="n">spin</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
                            <span class="n">dominant_contributions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">occ_orb</span><span class="o">=</span><span class="n">occ_orb</span><span class="p">,</span> <span class="n">virt_orb</span><span class="o">=</span><span class="n">virt_orb</span><span class="p">,</span>
                                                               <span class="n">coeff</span><span class="o">=</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">])))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;error while parsing line of escf dominant contribution: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>

                    <span class="n">exc_data</span><span class="p">[</span><span class="s2">&quot;dominant_contributions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dominant_contributions</span>

                <span class="c1"># Depending on the irrep there might be more &quot;columns&quot; with the dipole</span>
                <span class="c1"># and quadrupole values. Generate a list of dictionaries with these data.</span>
                <span class="n">moments_columns</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="s2">&quot; column&quot;</span> <span class="ow">in</span> <span class="n">exc_group</span><span class="p">:</span>
                    <span class="n">columns_to_parse</span> <span class="o">=</span> <span class="n">exc_group</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; column&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">columns_to_parse</span> <span class="o">=</span> <span class="p">[</span><span class="n">exc_group</span><span class="p">]</span>

                <span class="c1"># loop over the columns for the electric and magnetic moments.</span>
                <span class="k">for</span> <span class="n">str_c</span> <span class="ow">in</span> <span class="n">columns_to_parse</span><span class="p">:</span>
                    <span class="n">moments_data</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">match_elec_dip</span> <span class="o">=</span> <span class="n">regec_elec_dip</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">str_c</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">match_elec_dip</span><span class="p">:</span>
                        <span class="n">el_dip</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match_elec_dip</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">):</span>
                                <span class="n">el_dip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span>

                        <span class="n">moments_data</span><span class="p">[</span><span class="s2">&quot;electric_dipole&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">el_dip</span>

                    <span class="n">match_mag_dip</span> <span class="o">=</span> <span class="n">regec_mag_dip</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">str_c</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">match_mag_dip</span><span class="p">:</span>
                        <span class="n">mag_dip</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match_mag_dip</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">):</span>
                                <span class="n">mag_dip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span>

                        <span class="n">moments_data</span><span class="p">[</span><span class="s2">&quot;magnetic_dipole&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mag_dip</span>

                    <span class="n">match_elec_quad</span> <span class="o">=</span> <span class="n">regec_elec_quad</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">str_c</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">match_elec_quad</span><span class="p">:</span>
                        <span class="n">quadrupole</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                        <span class="n">d_quadrupole</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match_elec_quad</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                            <span class="k">if</span> <span class="s2">&quot; xx &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="s2">&quot; yy &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                <span class="n">d_quadrupole</span><span class="p">[</span><span class="s2">&quot;trace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="s2">&quot; zz &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="s2">&quot; xy &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">quadrupole</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="s2">&quot; xz &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">quadrupole</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                <span class="n">d_quadrupole</span><span class="p">[</span><span class="s2">&quot;anisotropy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="s2">&quot; yz &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                                <span class="n">quadrupole</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">quadrupole</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                        <span class="n">d_quadrupole</span><span class="p">[</span><span class="s2">&quot;moment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quadrupole</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="n">moments_data</span><span class="p">[</span><span class="s2">&quot;electric_quadrupole&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_quadrupole</span>

                    <span class="k">if</span> <span class="n">moments_data</span><span class="p">:</span>
                        <span class="n">moments_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moments_data</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">moments_columns</span><span class="p">:</span>
                    <span class="n">exc_data</span><span class="p">[</span><span class="s2">&quot;moments_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">moments_columns</span>

                <span class="n">single_excitations_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exc_data</span><span class="p">)</span>

            <span class="n">excited_data</span><span class="p">[</span><span class="n">irrep</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_excitations_list</span>

        <span class="k">return</span> <span class="n">excited_data</span></div>

<div class="viewcode-block" id="Parser.rdgrad_memory"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.rdgrad_memory">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">rdgrad_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Memory allocated for rdgrad.</span>
<span class="sd">        Valid for rdgrad.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parses: Memory allocated for RDGRAD: 1 MiB</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Memory allocated for RDGRAD.*$&quot;</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span></div>

<div class="viewcode-block" id="Parser.gradient"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.gradient">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Values of the gradients and dielectric data.</span>
<span class="sd">        Valid for gradient executables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;gradients&quot;, a matrix of shape (natoms, 3) containing the values of</span>
<span class="sd">                the cartesian gradients, and &quot;dielectric&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parse the section starting with:</span>
        <span class="c1">#           ------------------------------------------------</span>
        <span class="c1">#            cartesian gradient of the energy (hartree/bohr)</span>
        <span class="c1">#           ------------------------------------------------</span>
        <span class="n">r</span> <span class="o">=</span> <span class="s2">&quot;cartesian gradient of the energy.*cartesian gradients written onto&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">grad_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="n">grad_data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Parse lines of the form:</span>
        <span class="c1"># dE/dx  0.0000000D+00 -0.2705802D-01  0.2705802D-01</span>
        <span class="c1"># dE/dy  0.0000000D+00  0.0000000D+00  0.0000000D+00</span>
        <span class="c1"># dE/dz  0.4144103D-01 -0.2070390D-01 -0.2070390D-01</span>
        <span class="c1">#</span>
        <span class="c1"># Notice that they can span multiple sets of lines.</span>

        <span class="n">gradients</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]):</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;dE/d&quot;</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;(.*?)$&quot;</span><span class="p">,</span> <span class="n">grad_str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">g_vals</span> <span class="ow">in</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">g_vals</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="n">gradients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

        <span class="n">grad_data</span><span class="p">[</span><span class="s2">&quot;gradients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">gradients</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># Parses the lines:</span>
        <span class="c1">#  exx =      -0.076690 eyy =       0.000000 ezz =      -0.045091</span>
        <span class="c1">#  eyz =       0.000000 exz =      -0.000000 exy =       0.000000</span>

        <span class="n">dielectric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">grad_str</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;exx&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">dielectric</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">dielectric</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                <span class="n">dielectric</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
            <span class="k">elif</span> <span class="s2">&quot;eyz&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">dielectric</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dielectric</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">dielectric</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dielectric</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                <span class="n">dielectric</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dielectric</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>

        <span class="n">grad_data</span><span class="p">[</span><span class="s2">&quot;dielectric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dielectric</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">grad_data</span></div>

<div class="viewcode-block" id="Parser.egrad_excited_state"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.egrad_excited_state">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">egrad_excited_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information about the excited state chosen for optimization in egrad.</span>
<span class="sd">        Valid only for egrad.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;index&quot; indicating the (1-based) index of the state used for</span>
<span class="sd">            optimization and &quot;default&quot; to True if the default values used for $exopt.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parses:  Excited state no.    3 chosen for optimization</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Excited state no.\s+(\d+)\s+chosen for optimization&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">convert_int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Data group $exopt missing or empty&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Parser.statpt_info"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.statpt_info">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">statpt_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initial information provided in statpt.</span>
<span class="sd">        Valid only for statpt.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;max_trust_radius&quot;, &quot;min_trust_radius&quot;, &quot;init_trust_radius&quot;, &quot;min_grad_norm_for_gdiis&quot;,</span>
<span class="sd">            &quot;prev_steps_for_gdiis&quot;, &quot;hessian_update_method&quot;, &quot;thr_energy_change&quot;, &quot;thr_max_displ&quot;, &quot;thr_max_grad&quot;,</span>
<span class="sd">            &quot;thr_rms_displ&quot;, &quot;thr_rms_grad&quot;, &quot;use_defaults&quot;, &quot;final_step_radius&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See test files for examples. Parses the block starting with:</span>
        <span class="c1"># ***************  Stationary point options ******************</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Stationary point options[\s\*]{60,}(.+?)\*{60,}&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">max_trust_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">min_trust_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">init_trust_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">min_grad_norm_for_gdiis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">prev_steps_for_gdiis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">hessian_update_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">thr_energy_change</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">thr_max_displ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">thr_max_grad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">thr_rms_displ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">thr_rms_grad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">use_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">final_step_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="k">if</span> <span class="s2">&quot;Maximum allowed trust radius&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;max_trust_radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;Minimum allowed trust radius&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;min_trust_radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;Initial trust radius&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;init_trust_radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;GDIIS used if gradient norm&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;min_grad_norm_for_gdiis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;Number of previous steps for GDIIS&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;prev_steps_for_gdiis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;Hessian update method&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hessian_update_method&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;Threshold for energy change&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;thr_energy_change&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;Threshold for max displacement element&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;thr_max_displ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;Threshold for max gradient element&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;thr_max_grad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;Threshold for RMS of displacement&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;thr_rms_displ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;Threshold for RMS of gradient&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;thr_rms_grad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;use_defaults&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Keyword $statpt not found - using default options&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$\s+Final\s+step\s+radius\s*:\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_e_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;final_step_radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Parser.relax_info"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.relax_info">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">relax_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initial information provided in relax.</span>
<span class="sd">        Valid only for relax.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;optimizations&quot; list of optimized quantities and &quot;thr_int_coord&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">optimizations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">thr_int_coord</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Parses for example:</span>
        <span class="c1">#  optimization will be performed with respect to</span>
        <span class="c1">#  - INTERNAL coordinates</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;optimization will be performed with respect to\s+(.*?)-{10,}&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">opt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">):</span>
                    <span class="n">opt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;optimizations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">opt</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$\s+convergence\s+criterion\s+for\s+internal\s+coordinates\s*:\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_e_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;thr_int_coord&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Parser.relax_gradient_values"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.relax_gradient_values">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">relax_gradient_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gradient values extracted from the relax/stapt output that taking into account</span>
<span class="sd">        the frozen coordinates.</span>
<span class="sd">        Valid for relax and statpt.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;norm_cartesian&quot;, &quot;norm_internal&quot;, &quot;max_internal&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Parses:</span>
        <span class="c1">#   norm of actual CARTESIAN gradient : .54369</span>
        <span class="c1">#   norm of actual  INTERNAL gradient : .55998</span>
        <span class="c1">#   maximum norm of actual  INTERNAL gradient : .46843</span>

        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">norm_cartesian</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">norm_internal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">max_internal</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$\s+norm\s+of\s+actual\s+CARTESIAN\s+gradient\s*:\s+(&quot;</span><span class="o">+</span><span class="n">float_number_e_re</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;)&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;norm_cartesian&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$\s+norm\s+of\s+actual\s+INTERNAL\s+gradient\s*:\s+(&quot;</span><span class="o">+</span><span class="n">float_number_e_re</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;)&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;norm_internal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;maximum\s+norm\s+of\s+actual\s+INTERNAL\s+gradient\s*:\s+(&quot;</span><span class="o">+</span><span class="n">float_number_e_re</span><span class="o">+</span><span class="sa">r</span><span class="s2">&quot;)&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;max_internal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Parser.relax_conv_info"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.relax_conv_info">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">relax_conv_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Final information about convergence according to what is defined in the</span>
<span class="sd">        control file.</span>
<span class="sd">        Valid for relax and statpt.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;energy_change&quot;, &quot;rms_displ&quot;, &quot;rms_grad&quot;, &quot;max_displ&quot;, &quot;max_grad&quot;.</span>
<span class="sd">            For each one a dict with &quot;value&quot;, &quot;thr&quot; and &quot;conv&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parses:</span>
        <span class="c1">#       ******************************************************************</span>
        <span class="c1">#                           CONVERGENCE INFORMATION</span>
        <span class="c1">#</span>
        <span class="c1">#                                Converged?     Value      Criterion</span>
        <span class="c1">#              Energy change         no      76.3430059   0.0000010</span>
        <span class="c1">#              RMS of displacement   no       0.0517230   0.0005000</span>
        <span class="c1">#              RMS of gradient       no       0.0340771   0.0005000</span>
        <span class="c1">#              MAX displacement      no       0.0731468   0.0010000</span>
        <span class="c1">#              MAX gradient          no       0.0481922   0.0010000</span>
        <span class="c1">#       ******************************************************************</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;CONVERGENCE INFORMATION.*?Criterion\s*(.+?)\*{60,}&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">get_single_data</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">converged</span> <span class="o">=</span> <span class="s2">&quot;yes&quot;</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="s2">&quot;thr&quot;</span><span class="p">:</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="s2">&quot;conv&quot;</span><span class="p">:</span> <span class="n">converged</span><span class="p">}</span>

        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">energy_change</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">rms_displ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">rms_grad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">max_displ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">max_grad</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;Energy change&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;energy_change&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_single_data</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;RMS of displacement&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rms_displ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_single_data</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;RMS of gradient&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rms_grad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_single_data</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;MAX displacement&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;max_displ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_single_data</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;MAX geom. grad.&quot;</span> <span class="ow">in</span> <span class="n">l</span> <span class="ow">or</span> <span class="s2">&quot;MAX gradient&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;max_grad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_single_data</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Parser.aoforce_numerical_integration"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.aoforce_numerical_integration">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">aoforce_numerical_integration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information about the numerical integration in aoforce.</span>
<span class="sd">        Will be present only if a proper aoforce is run. Absent if running after numforce.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;memory&quot; (a dict with &quot;core_memory_dft&quot;, &quot;memory_per_atom&quot;, &quot;atoms_per_loop&quot;) and</span>
<span class="sd">            &quot;construction_timings&quot; (a list of lists with construction timings. For each element:</span>
<span class="sd">                [str with description of the timing, cpu time in seconds, wall time in seconds]).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This section may not be present if aoforce runs after a numforce but also</span>
        <span class="c1">#  if the calculation is not dft.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;PREPARING NUMERICAL INTEGRATION.*atoms per loop&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">memory</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="k">if</span> <span class="s2">&quot;Remaining core memory for DFT&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">memory</span><span class="p">[</span><span class="s2">&quot;core_memory_dft&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;Memory needed per atom&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">memory</span><span class="p">[</span><span class="s2">&quot;memory_per_atom&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;atoms per loop&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">memory</span><span class="p">[</span><span class="s2">&quot;atoms_per_loop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">memory</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">timings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># this matches a series a of &quot;CONSTRUCTING xxx to get their timings. Example:</span>
        <span class="c1">#  CONSTRUCTING first deriv. of &lt;mu|x,y,z|nu&gt; -&gt; Dip. deriv.</span>
        <span class="c1">#   ...</span>
        <span class="c1">#       ...terminated. cpu:       0.00       wall:       0.00</span>
        <span class="c1"># it skips the CONSTRUCTING integral bounds, that does not contain any timing.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;CONSTRUCTING((?! integral bounds).*?wall:\s+\d\.\d+)\s+(?=CONSTRUCTING|SOLVING|-------)&quot;</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">):</span>
            <span class="c1"># consider a different case for the second deriv. of 2e energy</span>
            <span class="c1"># since if it a dft calculations there are two timings there.</span>
            <span class="k">if</span> <span class="s2">&quot;second deriv. of 2e energy&quot;</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">gl</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
                <span class="n">treating_line</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gl</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="s2">&quot;treating&quot;</span> <span class="ow">in</span> <span class="n">gl</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">treating_line</span> <span class="o">=</span> <span class="n">gl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="s2">&quot;...terminated&quot;</span> <span class="ow">in</span> <span class="n">gl</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">gls</span> <span class="o">=</span> <span class="n">gl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="n">timings</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">gl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">treating_line</span><span class="p">,</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">gls</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]),</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">gls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">cpu</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">wall</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                    <span class="k">if</span> <span class="s2">&quot;...terminated&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="n">cpu</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
                        <span class="n">wall</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="ow">in</span> <span class="n">l</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;&lt;&quot;</span> <span class="ow">and</span> <span class="s2">&quot;&gt;&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;[&quot;</span> <span class="ow">and</span> <span class="s2">&quot;]&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">):</span>
                        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                <span class="n">timings</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">),</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">wall</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">memory</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">timings</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="n">memory</span><span class="p">,</span> <span class="n">construction_timings</span><span class="o">=</span><span class="n">timings</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Parser.aoforce_analysis"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.aoforce_analysis">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">aoforce_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output of rotational and vibrational analysis in aoforce.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;rotational&quot; (a dict with &quot;dipole_moment&quot;, &quot;b&quot;, &quot;intensities&quot;, &quot;m&quot;) and &quot;vibrational&quot;.</span>
<span class="sd">            Vibrational, contains dict with keys &quot;frequencies&quot;, &quot;symmetries&quot;, &quot;ir&quot;, &quot;dDIP_dQ&quot;, &quot;intensities&quot;,</span>
<span class="sd">            &quot;intensities_perc&quot;, &quot;raman&quot;, &quot;eigenvectors&quot;, &quot;reduced_masses&quot;. One value for each frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># See test files for examples. Parses the section starting with:</span>
        <span class="c1">#              -----------------------------------</span>
        <span class="c1">#              rotational and vibrational analysis</span>
        <span class="c1">#              -----------------------------------</span>
        <span class="n">split1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;dipole moment in principle axis system&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">split2</span> <span class="o">=</span> <span class="n">split1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;NORMAL MODES and VIBRATIONAL FREQUENCIES&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Rotational section</span>
        <span class="c1"># Parses:</span>
        <span class="c1">#  dipole moment in principle axis system (a.u.) :</span>
        <span class="c1">#     -0.0000000000     0.0000000000     0.8436248828</span>
        <span class="c1">#  norm :  0.843624882772472</span>
        <span class="c1">#</span>
        <span class="c1">#  rotational constants b for rotations around axis of inertia</span>
        <span class="c1">#  and optical intensities for (1 &lt;-- 0) transition</span>
        <span class="c1">#</span>
        <span class="c1">#    b   :    25.5620992978     9.0755697626    14.0715251781   (cm**(-1))</span>
        <span class="c1">#    b   :      766332.4580      272078.7367      421853.7121     (MHz)</span>
        <span class="c1">#   int. :     0.0000000000     0.0000000000     0.7117029428     (a.u.)</span>
        <span class="c1">#</span>
        <span class="c1">#    x   :     1.0000000000     0.0000000000     0.0000000000</span>
        <span class="c1">#    y   :     0.0000000000     1.0000000000     0.0000000000</span>
        <span class="c1">#    z   :     0.0000000000     0.0000000000     1.0000000000</span>


        <span class="n">rot</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">rot_lines</span> <span class="o">=</span> <span class="n">split2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>

        <span class="n">rot</span><span class="p">[</span><span class="s2">&quot;dipole_moment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">rot_lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">rot_intensities</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">m</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">rot_lines</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;b &quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;cm&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;int.&quot;</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">rot_intensities</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;x &quot;</span><span class="p">):</span>
                <span class="c1"># the x :   y :   z : section may be missing.</span>
                <span class="c1"># Initialize m here only if it is actually filled</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span> <span class="o">*</span> <span class="mi">3</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;y &quot;</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;z &quot;</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>

        <span class="c1">#TODO verify the meaning of int and m</span>
        <span class="n">rot</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">rot</span><span class="p">[</span><span class="s2">&quot;intensities&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rot_intensities</span>
        <span class="n">rot</span><span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>

        <span class="c1"># Vibrational section</span>
        <span class="c1"># Parses groups of the form:</span>
        <span class="c1">#        mode               7        8        9</span>
        <span class="c1">#</span>
        <span class="c1">#      frequency        1603.56  3527.41  3641.97</span>
        <span class="c1">#</span>
        <span class="c1">#      symmetry            a1       a1       b1</span>
        <span class="c1">#</span>
        <span class="c1">#         IR               YES      YES      YES</span>
        <span class="c1"># |dDIP/dQ|   (a.u.)     0.0059   0.0002   0.0031</span>
        <span class="c1"># intensity (km/mol)      62.07     0.11    16.54</span>
        <span class="c1"># intensity (  %   )     100.00     0.17    26.64</span>
        <span class="c1">#</span>
        <span class="c1">#        RAMAN             YES      YES      YES</span>
        <span class="c1">#</span>
        <span class="c1">#   1   o           x  -0.00000  0.00000  0.06983</span>
        <span class="c1">#                   y   0.00000  0.00000  0.00000</span>
        <span class="c1">#                   z   0.07060  0.04999 -0.00000</span>
        <span class="c1">#   2   h           x   0.42845 -0.58424 -0.55423</span>
        <span class="c1">#                   y   0.00000  0.00000  0.00000</span>
        <span class="c1">#                   z  -0.56031 -0.39676 -0.43634</span>
        <span class="c1">#   3   h           x  -0.42845  0.58424 -0.55423</span>
        <span class="c1">#                   y  -0.00000  0.00000  0.00000</span>
        <span class="c1">#                   z  -0.56031 -0.39676  0.43634</span>
        <span class="c1">#</span>
        <span class="c1"># reduced mass(g/mol)     1.083    1.045    1.081</span>

        <span class="n">frequencies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">symmetries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ir</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dDIP_dQ</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vib_intensities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vib_intensities_perc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">raman</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eigenvectors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">reduced_masses</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">regex_eigenvectors</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.*?)(^[ \t]+\d+\s+[a-z]{1,2}.*?)(reduced mass.*)&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_active_value</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Converts the value to a bool. If &quot;-&quot; is set to None.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;YES&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;NO&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot correctly parse active value </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

        <span class="c1"># splits the block of lines with one set of frequencies and loops over them</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(mode\s</span><span class="si">{5}</span><span class="s2">.*?)(?=mode |\*{10,})&quot;</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">split2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">):</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">regex_eigenvectors</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">block_freqs</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">block_eigenvectors</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">freqs_lines</span> <span class="o">=</span> <span class="n">block_freqs</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
            <span class="n">n_freqs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># loop over the lines of the block, extract all the properties</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">freqs_lines</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;frequency&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="c1"># put imaginary frequencies to negative values.</span>
                    <span class="n">frequencies</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">convert_float</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">elif</span> <span class="s2">&quot;symmetry&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="c1"># put the symmetries that are present</span>
                    <span class="n">symmetries</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sym</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="c1"># add None values for those that are not present</span>
                    <span class="n">symmetries</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_freqs</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">elif</span> <span class="s2">&quot;IR &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">ir</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get_active_value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">elif</span> <span class="s2">&quot;|dDIP/dQ|&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">dDIP_dQ</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">convert_float</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
                <span class="k">elif</span> <span class="s2">&quot;intensity (km/mol)&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">vib_intensities</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">convert_float</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
                <span class="k">elif</span> <span class="s2">&quot;intensity&quot;</span> <span class="ow">in</span> <span class="n">l</span> <span class="ow">and</span> <span class="s2">&quot;%&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">vib_intensities_perc</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">convert_float</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:])</span>
                <span class="k">elif</span> <span class="s2">&quot;RAMAN &quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">raman</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get_active_value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">elif</span> <span class="s2">&quot;reduced mass&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">reduced_masses</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">convert_float</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

            <span class="n">eig_lines</span> <span class="o">=</span> <span class="n">block_eigenvectors</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eig_lines</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;number of line to be parsed for eigenvectors seems wrong: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">eig_lines</span><span class="p">)))</span>

            <span class="n">n_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eig_lines</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
            <span class="n">eigv_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_freqs</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">eig_lines</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="n">eigv_block</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="n">n_freqs</span><span class="p">:]]</span>

            <span class="n">eigenvectors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">eigv_block</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="n">energies</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">re_zpve</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;zero point VIBRATIONAL energy.*?\*{10,}&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">re_zpve</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">energies</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;zpve&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;scf&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                <span class="k">if</span> <span class="s2">&quot;zero point VIBRATIONAL energy&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">energies</span><span class="p">[</span><span class="s2">&quot;zpve&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;SCF-energy&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">energies</span><span class="p">[</span><span class="s2">&quot;scf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;SCF + E(vib0)&quot;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">energies</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">vib</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">frequencies</span><span class="o">=</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">symmetries</span><span class="o">=</span><span class="n">symmetries</span><span class="p">,</span> <span class="n">ir</span><span class="o">=</span><span class="n">ir</span><span class="p">,</span> <span class="n">dDIP_dQ</span><span class="o">=</span><span class="n">dDIP_dQ</span><span class="p">,</span>
                   <span class="n">intensities</span><span class="o">=</span><span class="n">vib_intensities</span><span class="p">,</span> <span class="n">intensities_perc</span><span class="o">=</span><span class="n">vib_intensities_perc</span><span class="p">,</span>
                   <span class="n">raman</span><span class="o">=</span><span class="n">raman</span><span class="p">,</span> <span class="n">eigenvectors</span><span class="o">=</span><span class="n">eigenvectors</span><span class="p">,</span> <span class="n">reduced_masses</span><span class="o">=</span><span class="n">reduced_masses</span><span class="p">,</span>
                   <span class="n">energies</span><span class="o">=</span><span class="n">energies</span><span class="p">)</span>

        <span class="n">tot_n_freqs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;energies&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="n">tot_n_freqs</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vib</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Error parsing the vibrational frequencies, for some quantity the list of &quot;</span>
                               <span class="s2">&quot;values does not contain the correct number of items&quot;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rotational</span><span class="o">=</span><span class="n">rot</span><span class="p">,</span> <span class="n">vibrational</span><span class="o">=</span><span class="n">vib</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Parser.mp2_data"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.mp2_data">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">mp2_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MP2 data: information of MP2 calculation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;energy_only&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: implement or mpgrad and rimp2/ricc2</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Parser.mp2_results"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.mp2_results">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">mp2_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MP2 results.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;energy&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">energy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Try to parse from rimp2/ricc2 programs</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\*{62,62}\s+\*\s+\*\s+\*&lt;{10,10}\s+&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;GROUND\s+STATE\s+FIRST-ORDER\s+PROPERTIES&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;\s+&gt;{11,11}\*\s+\*\s+\*\s+\*{62,62}\s+&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;-{48,48}\s+Method\s+:\s+MP2\s+Total\s+Energy\s+:\s+(&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="n">float_number_all_re</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;)\s+&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Error parsing the MP2 results. Multiple occurrences of MP2 results found.&quot;</span><span class="p">)</span>

        <span class="c1"># Try to parse from mpgrad program</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\*{53,53}\s+\*\s+\*\s+\*\s+&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;SCF-energy\s+:\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_all_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)\s+\*\s+\*\s+&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;MP2-energy\s+:\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_all_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)\s+\*\s+\*\s+&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;total\s+:\s+(&quot;</span> <span class="o">+</span> <span class="n">float_number_all_re</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)\s+\*\s+\*\s+&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;\*\s+\*\s+\(MP2-energy\s+evaluated\s+from\s+T2\s+amplitudes\)\s+\*\s+\*\s+\*\s+\*{53,53}&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Error parsing the MP2 results. &quot;</span>
                                   <span class="s2">&quot;Found MP2 results from both mpgrad- and rimp2/ricc2-like calculations.&quot;</span><span class="p">)</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Error parsing the MP2 results. Multiple occurrences of MP2 results found.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="n">energy</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parser.periodicity_data"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.periodicity_data">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">periodicity_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information about periodicity.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict with &quot;periodicity&quot;, &quot;tm_lattice_params&quot;, &quot;shortest_interatomic_distance&quot;,</span>
<span class="sd">                &quot;direct_space_vectors&quot;, &quot;reciprocal_space_vectors&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Periodic system found\: PBC structure information.*&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;Reciprocal space cell vectors \(au\)\:\s+&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;(?:[a|b|c]\s+&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="n">float_number_all_re</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="n">float_number_all_re</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="n">float_number_all_re</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;\s+){1,3}&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;More than one section on periodicity.&#39;</span><span class="p">)</span>
        <span class="n">periodicity_string</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">periodicity</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Periodicity in (\d) dimensions&quot;</span><span class="p">,</span> <span class="n">periodicity_string</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">periodicity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rlatparams</span> <span class="o">=</span> <span class="sa">rf</span><span class="s2">&quot;\+-</span><span class="se">{{</span><span class="s2">73</span><span class="se">}}</span><span class="s2">\s+(</span><span class="si">{</span><span class="n">float_number_all_re</span><span class="si">}</span><span class="s2">)\s+\+-</span><span class="se">{{</span><span class="s2">73</span><span class="se">}}</span><span class="s2">&quot;</span>
            <span class="n">tm_lattice_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">rlatparams</span><span class="p">,</span> <span class="n">periodicity_string</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">periodicity</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">rlatparams</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\+-</span><span class="si">{73}</span><span class="s2">&quot;</span>
            <span class="n">rlatparams</span> <span class="o">+=</span> <span class="sa">rf</span><span class="s2">&quot;\s+(</span><span class="si">{</span><span class="n">float_number_all_re</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="n">rlatparams</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;\s+\+-</span><span class="si">{73}</span><span class="s2">&quot;</span>
            <span class="n">tm_lattice_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">rlatparams</span><span class="p">,</span> <span class="n">periodicity_string</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">periodicity</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">rlatparams</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\+-</span><span class="si">{73}</span><span class="s2">&quot;</span>
            <span class="n">rlatparams</span> <span class="o">+=</span> <span class="sa">rf</span><span class="s2">&quot;\s+(</span><span class="si">{</span><span class="n">float_number_all_re</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="o">*</span> <span class="mi">6</span>
            <span class="n">rlatparams</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;\s+\+-</span><span class="si">{73}</span><span class="s2">&quot;</span>
            <span class="n">tm_lattice_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="k">for</span> <span class="n">lp</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">rlatparams</span><span class="p">,</span> <span class="n">periodicity_string</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Wrong periodicity.&#39;</span><span class="p">)</span>

        <span class="n">shortest_interatomic_distance</span> <span class="o">=</span> <span class="n">convert_float</span><span class="p">(</span>
            <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                <span class="sa">rf</span><span class="s2">&quot;Shortest interatomic distance \(bohr\)\:\s+(</span><span class="si">{</span><span class="n">float_number_all_re</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="n">periodicity_string</span>
            <span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">rdirect</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Direct space cell vectors \(au\)\:&quot;</span>
        <span class="n">rdirect</span> <span class="o">+=</span> <span class="sa">rf</span><span class="s2">&quot;\s+[a|b|c]\s+(</span><span class="si">{</span><span class="n">float_number_all_re</span><span class="si">}</span><span class="s2">)\s+(</span><span class="si">{</span><span class="n">float_number_all_re</span><span class="si">}</span><span class="s2">)\s+(</span><span class="si">{</span><span class="n">float_number_all_re</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="o">*</span> <span class="n">periodicity</span>
        <span class="n">direct_space_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">rdirect</span><span class="p">,</span> <span class="n">periodicity_string</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()],</span>
            <span class="p">(</span><span class="n">periodicity</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">r_recip</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;Reciprocal space cell vectors \(au\)\:&quot;</span>
        <span class="n">r_recip</span> <span class="o">+=</span> <span class="sa">rf</span><span class="s2">&quot;\s+[a|b|c]\s+(</span><span class="si">{</span><span class="n">float_number_all_re</span><span class="si">}</span><span class="s2">)\s+(</span><span class="si">{</span><span class="n">float_number_all_re</span><span class="si">}</span><span class="s2">)\s+(</span><span class="si">{</span><span class="n">float_number_all_re</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="o">*</span> <span class="n">periodicity</span>
        <span class="n">reciprocal_space_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">[</span><span class="n">convert_float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r_recip</span><span class="p">,</span> <span class="n">periodicity_string</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()],</span>
            <span class="p">(</span><span class="n">periodicity</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">periodicity</span><span class="o">=</span><span class="n">periodicity</span><span class="p">,</span> <span class="n">tm_lattice_params</span><span class="o">=</span><span class="n">tm_lattice_params</span><span class="p">,</span>
                    <span class="n">shortest_interatomic_distance</span><span class="o">=</span><span class="n">shortest_interatomic_distance</span><span class="p">,</span>
                    <span class="n">direct_space_vectors</span><span class="o">=</span><span class="n">direct_space_vectors</span><span class="p">,</span>
                    <span class="n">reciprocal_space_vectors</span><span class="o">=</span><span class="n">reciprocal_space_vectors</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parser.get_split_jobex_parsers"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.get_split_jobex_parsers">[docs]</a>    <span class="k">def</span> <span class="nf">get_split_jobex_parsers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the string of the &quot;job.last&quot; output file of jobex generates the</span>
<span class="sd">        parsers for each of the step: energy, gradient and relax.</span>

<span class="sd">        Returns:</span>
<span class="sd">            namedtuple:</span>
<span class="sd">                exec_en: executable of the energy step.</span>
<span class="sd">                parser_en: parser with the output of the energy step.</span>
<span class="sd">                exec_grad: executable of the gradient step.</span>
<span class="sd">                parser_grad: parser with the output of the gradient step.</span>
<span class="sd">                exec_relax: executable of the energy step.</span>
<span class="sd">                parser_relax: parser with the output of the relax step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tot_split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;next step =&quot;</span><span class="p">)</span>
        <span class="n">p_en</span> <span class="o">=</span> <span class="n">p_grad</span> <span class="o">=</span> <span class="n">p_relax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">exec_en</span> <span class="o">=</span> <span class="n">exec_grad</span> <span class="o">=</span> <span class="n">exec_relax</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tot_split</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">header</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">header</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">executable</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="s2">&quot;executable&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">executable</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;dscf&quot;</span><span class="p">,</span> <span class="s2">&quot;ridft&quot;</span><span class="p">,</span> <span class="s2">&quot;riper&quot;</span><span class="p">):</span>
                <span class="n">p_en</span> <span class="o">=</span> <span class="n">p</span>
                <span class="n">exec_en</span> <span class="o">=</span> <span class="n">executable</span>
            <span class="k">elif</span> <span class="n">executable</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;grad&quot;</span><span class="p">,</span> <span class="s2">&quot;rdgrad&quot;</span><span class="p">,</span> <span class="s2">&quot;egrad&quot;</span><span class="p">,</span> <span class="s2">&quot;mpgrad&quot;</span><span class="p">,</span> <span class="s2">&quot;ricc2&quot;</span><span class="p">):</span>
                <span class="n">p_grad</span> <span class="o">=</span> <span class="n">p</span>
                <span class="n">exec_grad</span> <span class="o">=</span> <span class="n">executable</span>
            <span class="k">elif</span> <span class="n">executable</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;relax&quot;</span><span class="p">,</span> <span class="s2">&quot;statpt&quot;</span><span class="p">,</span> <span class="s2">&quot;frog&quot;</span><span class="p">):</span>
                <span class="n">p_relax</span> <span class="o">=</span> <span class="n">p</span>
                <span class="n">exec_relax</span> <span class="o">=</span> <span class="n">executable</span>

        <span class="n">JobexParsers</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;JobexParsers&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;exec_en&quot;</span><span class="p">,</span> <span class="s2">&quot;parser_en&quot;</span><span class="p">,</span> <span class="s2">&quot;exec_grad&quot;</span><span class="p">,</span> <span class="s2">&quot;parser_grad&quot;</span><span class="p">,</span> <span class="s2">&quot;exec_relax&quot;</span><span class="p">,</span> <span class="s2">&quot;parser_relax&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">JobexParsers</span><span class="p">(</span><span class="n">exec_en</span><span class="p">,</span> <span class="n">p_en</span><span class="p">,</span> <span class="n">exec_grad</span><span class="p">,</span> <span class="n">p_grad</span><span class="p">,</span> <span class="n">exec_relax</span><span class="p">,</span> <span class="n">p_relax</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parser.grep_line"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.grep_line">[docs]</a>    <span class="k">def</span> <span class="nf">grep_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">nlines</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches the specified text in a single line and return the full line plus</span>
<span class="sd">        the &quot;nlines&quot; following the matching one. Returns the first match.</span>

<span class="sd">        Args:</span>
<span class="sd">            text (str): the text to be searched.</span>
<span class="sd">            nlines (int): the number of lines</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: the text found</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^.*&quot;</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;.*$(\n.*){0,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nlines</span><span class="p">)</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;}&quot;</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parser.get_value"><a class="viewcode-back" href="../../../api/turbomoleio.output.html#turbomoleio.output.parser.Parser.get_value">[docs]</a>    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">occurrence</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">converter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the i-th occurrence of a line containing the specified text,</span>
<span class="sd">        splits the line and takes the specified chunk obtained from the split.</span>
<span class="sd">        Optionally converts it to a specific format.</span>

<span class="sd">        Args:</span>
<span class="sd">            text (str): text to search</span>
<span class="sd">            chunk (int): the chunk to take after the split of the line.</span>
<span class="sd">                Can be negative as it identifies the index in the list.</span>
<span class="sd">            occurrence (int): the 0-based index of the occurrence of the &quot;text&quot;</span>
<span class="sd">                in the string. Can be negative (e.g. -1 is the last occurrence).</span>
<span class="sd">            converter (callable): called to convert the selected chunk to some</span>
<span class="sd">                other type. It can be simply int, but for a float it would be better</span>
<span class="sd">                to use the convert_float function instead.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the converted selected chunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^.*&quot;</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;.*$&quot;</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">line</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">occurrence</span><span class="p">]</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="n">chunk</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">converter</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">converter</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">v</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018-2021 BASF SE, Matgenix SRL.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>